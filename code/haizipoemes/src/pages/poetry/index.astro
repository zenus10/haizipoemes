---
// Poetry Index Page - 诗歌总览页
// 左侧筛选栏 + 右侧诗歌列表（虚拟滚动）

import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import { poemTypes, poemYears } from '../../lib/filters';
import '../../styles/pages/poetry-index.css';

// 获取所有诗歌并排序
const poemsCollection = await getCollection('poems');
const poems = poemsCollection
  .sort((a, b) => (a.data.order ?? 999) - (b.data.order ?? 999))
  .map(poem => ({
    id: poem.slug,
    title: poem.data.title,
    type: poem.data.type,
    year: poem.data.year,
  }));
---

<BaseLayout title="诗歌" currentPage="poetry" fullWidth>
  <!-- 将诗歌数据注入客户端 -->
  <script define:vars={{ poems }}>
    window.__POEMS_DATA__ = poems;
  </script>

  <div class="poetry-page">
    <!-- 左侧筛选栏 -->
    <aside class="filter-sidebar">
      <div class="filter-header">
        <span class="filter-title">筛选</span>
        <button class="filter-clear" id="clearFilters">清除</button>
      </div>

      <div class="filter-section">
        <h3 class="filter-section-title">TAGS</h3>

        <!-- 类型筛选 -->
        <div class="filter-group">
          <button class="filter-group-toggle" data-group="type">
            <span>类型</span>
            <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M6 9l6 6 6-6"/>
            </svg>
          </button>
          <div class="filter-options" data-group-content="type">
            {poemTypes.map((type) => (
              <label class="filter-option">
                <input type="checkbox" name="type" value={type.key} />
                <span class="checkbox-custom"></span>
                <span class="option-label">{type.label}</span>
              </label>
            ))}
          </div>
        </div>

        <!-- 时间筛选 -->
        <div class="filter-group">
          <button class="filter-group-toggle" data-group="year">
            <span>时间</span>
            <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M6 9l6 6 6-6"/>
            </svg>
          </button>
          <div class="filter-options" data-group-content="year">
            {poemYears.map((year) => (
              <label class="filter-option">
                <input type="checkbox" name="year" value={year} />
                <span class="checkbox-custom"></span>
                <span class="option-label">{year}</span>
              </label>
            ))}
          </div>
        </div>
      </div>
    </aside>

    <!-- 右侧诗歌列表 -->
    <main class="poetry-main">
      <!-- 搜索栏 -->
      <div class="search-row">
        <div class="search-bar">
          <div class="search-input-wrapper">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"/>
              <path d="M21 21l-4.35-4.35"/>
            </svg>
            <input
              type="text"
              class="search-input"
              placeholder="Search"
              id="poemSearch"
            />
          </div>
          <button class="search-button" id="searchButton">搜索</button>
        </div>
        <span class="poem-count" id="poemCount"></span>
      </div>

      <!-- 诗歌虚拟滚动列表 -->
      <div class="poem-list" id="poemList">
        <div class="virtual-scroll-sentinel" id="scrollSentinel"></div>
        <div class="virtual-scroll-viewport" id="scrollViewport"></div>
      </div>

      <!-- 空状态 -->
      <div class="poem-list-empty" id="poemListEmpty">
        未找到匹配的诗歌
      </div>
    </main>
  </div>
</BaseLayout>

<script>
  // 常量
  const ITEM_HEIGHT = 40;
  const OVERSCAN = 5;
  const DEBOUNCE_DELAY = 150;
  const SESSION_KEY = 'poetry-filter-state';

  interface PoemData {
    id: string;
    title: string;
    type: string;
    year: string;
  }

  interface FilterState {
    checkedTypes: string[];
    checkedYears: string[];
    searchText: string;
    scrollTop: number;
    collapsedGroups: string[];
  }

  function init() {
    // 数据
    const allPoems: PoemData[] = (window as any).__POEMS_DATA__ || [];

    // DOM 引用
    const poemListEl = document.getElementById('poemList') as HTMLDivElement;
    const sentinelEl = document.getElementById('scrollSentinel') as HTMLDivElement;
    const viewportEl = document.getElementById('scrollViewport') as HTMLDivElement;
    const searchInput = document.getElementById('poemSearch') as HTMLInputElement;
    const searchButton = document.getElementById('searchButton') as HTMLButtonElement;
    const clearButton = document.getElementById('clearFilters') as HTMLButtonElement;
    const countEl = document.getElementById('poemCount') as HTMLSpanElement;
    const emptyEl = document.getElementById('poemListEmpty') as HTMLDivElement;
    const filterToggles = document.querySelectorAll('.filter-group-toggle');
    const checkboxes = document.querySelectorAll<HTMLInputElement>('.filter-option input[type="checkbox"]');

    if (!poemListEl || !sentinelEl || !viewportEl) return;

    // 状态
    let filteredPoems: PoemData[] = [];
    let renderedStart = -1;
    let renderedEnd = -1;
    let debounceTimer: ReturnType<typeof setTimeout> | null = null;
    let scrollRafPending = false;
    let resizeTimer: ReturnType<typeof setTimeout> | null = null;

    // ===== 折叠/展开筛选组 =====
    filterToggles.forEach(toggle => {
      toggle.addEventListener('click', () => {
        const group = toggle.getAttribute('data-group');
        const content = document.querySelector(`[data-group-content="${group}"]`);
        toggle.classList.toggle('collapsed');
        content?.classList.toggle('hidden');
        saveState();
      });
    });

    // ===== 核心：应用筛选 =====
    function applyFilters(skipScrollReset = false) {
      const searchTerm = searchInput.value.toLowerCase().trim();
      const selectedTypes = Array.from(document.querySelectorAll<HTMLInputElement>('input[name="type"]:checked'))
        .map(input => input.value);
      const selectedYears = Array.from(document.querySelectorAll<HTMLInputElement>('input[name="year"]:checked'))
        .map(input => input.value);

      filteredPoems = allPoems.filter(poem => {
        const matchesSearch = !searchTerm || poem.title.toLowerCase().includes(searchTerm);
        const matchesType = selectedTypes.length === 0 || selectedTypes.includes(poem.type);
        const matchesYear = selectedYears.length === 0 || selectedYears.includes(poem.year);
        return matchesSearch && matchesType && matchesYear;
      });

      // 更新 sentinel 高度
      sentinelEl.style.height = filteredPoems.length * ITEM_HEIGHT + 'px';

      // 重置滚动位置（除非恢复状态）
      if (!skipScrollReset) {
        poemListEl.scrollTop = 0;
      }

      // 重置渲染范围以强制重绘
      renderedStart = -1;
      renderedEnd = -1;

      // 空状态（必须在 renderVisibleItems 之前，否则 display:none 导致 clientHeight=0）
      if (emptyEl) {
        const isEmpty = filteredPoems.length === 0;
        emptyEl.classList.toggle('visible', isEmpty);
        poemListEl.style.display = isEmpty ? 'none' : '';
      }

      // 渲染可见项
      renderVisibleItems();

      // 更新计数
      if (countEl) {
        countEl.textContent = filteredPoems.length === allPoems.length
          ? `${allPoems.length} 首`
          : `${filteredPoems.length} / ${allPoems.length} 首`;
      }

      saveState();
    }

    // ===== 核心：渲染可见项 =====
    function renderVisibleItems() {
      const scrollTop = poemListEl.scrollTop;
      const clientHeight = poemListEl.clientHeight;

      if (clientHeight === 0) return;

      const startIndex = Math.floor(scrollTop / ITEM_HEIGHT);
      const visibleCount = Math.ceil(clientHeight / ITEM_HEIGHT);

      const renderStart = Math.max(0, startIndex - OVERSCAN);
      const renderEnd = Math.min(filteredPoems.length, startIndex + visibleCount + OVERSCAN);

      // 如果范围没变则跳过
      if (renderStart === renderedStart && renderEnd === renderedEnd) return;

      renderedStart = renderStart;
      renderedEnd = renderEnd;

      // 构建 DOM 片段
      const fragment = document.createDocumentFragment();

      for (let i = renderStart; i < renderEnd; i++) {
        const poem = filteredPoems[i];
        const a = document.createElement('a');
        a.href = `/poetry/${poem.id}`;
        a.className = 'poem-item';
        a.style.top = i * ITEM_HEIGHT + 'px';
        a.style.height = ITEM_HEIGHT + 'px';

        const dot = document.createElement('span');
        dot.className = 'poem-dot';

        const title = document.createElement('span');
        title.className = 'poem-title';
        title.textContent = poem.title;

        a.appendChild(dot);
        a.appendChild(title);
        fragment.appendChild(a);
      }

      viewportEl.innerHTML = '';
      viewportEl.appendChild(fragment);
    }

    // ===== 滚动处理（rAF 节流） =====
    function onScroll() {
      if (!scrollRafPending) {
        scrollRafPending = true;
        requestAnimationFrame(() => {
          renderVisibleItems();
          scrollRafPending = false;
        });
      }
    }

    poemListEl.addEventListener('scroll', onScroll, { passive: true });

    // ===== 搜索防抖 =====
    searchInput?.addEventListener('input', () => {
      if (debounceTimer !== null) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        debounceTimer = null;
        applyFilters();
      }, DEBOUNCE_DELAY);
    });

    // 搜索按钮：立即触发
    searchButton?.addEventListener('click', () => {
      if (debounceTimer !== null) {
        clearTimeout(debounceTimer);
        debounceTimer = null;
      }
      applyFilters();
    });

    // ===== checkbox 筛选 =====
    checkboxes.forEach(checkbox => {
      checkbox.addEventListener('change', () => applyFilters());
    });

    // ===== 清除所有筛选 =====
    clearButton?.addEventListener('click', () => {
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      searchInput.value = '';
      // 恢复折叠组
      filterToggles.forEach(toggle => {
        toggle.classList.remove('collapsed');
        const group = toggle.getAttribute('data-group');
        const content = document.querySelector(`[data-group-content="${group}"]`);
        content?.classList.remove('hidden');
      });
      try {
        sessionStorage.removeItem(SESSION_KEY);
      } catch {}
      applyFilters();
    });

    // ===== sessionStorage 状态持久化 =====
    function saveState() {
      try {
        const collapsedGroups: string[] = [];
        filterToggles.forEach(toggle => {
          if (toggle.classList.contains('collapsed')) {
            const group = toggle.getAttribute('data-group');
            if (group) collapsedGroups.push(group);
          }
        });

        const state: FilterState = {
          checkedTypes: Array.from(document.querySelectorAll<HTMLInputElement>('input[name="type"]:checked'))
            .map(input => input.value),
          checkedYears: Array.from(document.querySelectorAll<HTMLInputElement>('input[name="year"]:checked'))
            .map(input => input.value),
          searchText: searchInput.value,
          scrollTop: poemListEl.scrollTop,
          collapsedGroups,
        };

        sessionStorage.setItem(SESSION_KEY, JSON.stringify(state));
      } catch {}
    }

    function restoreState(): boolean {
      try {
        const raw = sessionStorage.getItem(SESSION_KEY);
        if (!raw) return false;

        const state: FilterState = JSON.parse(raw);

        // 恢复 checkbox 状态
        checkboxes.forEach(checkbox => {
          const name = checkbox.name;
          const value = checkbox.value;
          if (name === 'type') {
            checkbox.checked = state.checkedTypes.includes(value);
          } else if (name === 'year') {
            checkbox.checked = state.checkedYears.includes(value);
          }
        });

        // 恢复搜索文本
        searchInput.value = state.searchText || '';

        // 恢复折叠状态
        if (state.collapsedGroups && state.collapsedGroups.length > 0) {
          filterToggles.forEach(toggle => {
            const group = toggle.getAttribute('data-group');
            if (group && state.collapsedGroups.includes(group)) {
              toggle.classList.add('collapsed');
              const content = document.querySelector(`[data-group-content="${group}"]`);
              content?.classList.add('hidden');
            }
          });
        }

        // 应用筛选（不重置滚动位置）
        applyFilters(true);

        // 恢复滚动位置
        if (state.scrollTop > 0) {
          poemListEl.scrollTop = state.scrollTop;
          renderVisibleItems();
        }

        return true;
      } catch {
        return false;
      }
    }

    // ===== 窗口 resize 处理 =====
    window.addEventListener('resize', () => {
      if (resizeTimer !== null) {
        clearTimeout(resizeTimer);
      }
      resizeTimer = setTimeout(() => {
        resizeTimer = null;
        renderedStart = -1;
        renderedEnd = -1;
        renderVisibleItems();
      }, 100);
    });

    // ===== bfcache 兼容 =====
    window.addEventListener('pageshow', (event) => {
      if (event.persisted) {
        restoreState();
      }
    });

    // ===== 滚动时保存位置（节流） =====
    let scrollSaveTimer: ReturnType<typeof setTimeout> | null = null;
    poemListEl.addEventListener('scroll', () => {
      if (scrollSaveTimer !== null) {
        clearTimeout(scrollSaveTimer);
      }
      scrollSaveTimer = setTimeout(() => {
        scrollSaveTimer = null;
        saveState();
      }, 300);
    }, { passive: true });

    // ===== 初始化 =====
    const restored = restoreState();
    if (!restored) {
      applyFilters();
    }
  }

  // 确保 DOM 就绪后执行
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
